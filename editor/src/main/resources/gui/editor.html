<!DOCTYPE html>
<html>
<head>
    <style id="style"></style>
    <script>
        /* DEBUG FUNCTIONS! */
        function stringify_path(node)
        {
            var ret = "";

            while(node != null)
            {
                switch(node.nodeType)
                {
                    case 1:
                        var attrs = node.attributes;
                        if(attrs.length != 0)
                        {
                            ret = "]/" + ret;
                            for(i = 0; i < attrs.length; ++i)
                            {
                                if(i != 0)
                                    ret = "," + ret;

                                var attr = attrs.item(i);
                                ret = attr.name + "='" + attr.value + "'" + ret;
                            }
                            ret = "[" + ret;
                        }
                        ret = node.nodeName + ret;
                        break;
                    case 3:
                        var content = node.textContent;
                        if(content.length > 32)
                            content = content.substring(0, 29) + "...";
                        ret = node.nodeName + "[text='" + content + "']" + "/" + ret;
                        break;
                    default:
                        ret = node.nodeName + "/" + ret;
                        break;
                }

                node = node.parentNode;
            }

            return ret;
        }

        function stringify_range(range)
        {
            var ret = "";
            ret += "start = " + stringify_path(range.startContainer) + "[" + range.startOffset + "]";
            ret += "end   = " + stringify_path(range.endContainer) + "[" + range.endOffset + "]";
            return ret;
        }

        function make_selection_valid(e)
        {
            var selection = window.getSelection();
            var editor = document.getElementById("editor");

            if(selection.rangeCount < 1 ||
               !editor.contains(selection.anchorNode) ||
               !editor.contains(selection.focusNode))
            {
                selection.removeAllRanges();

                var range = document.createRange();
                range.setStart(editor, 0);
                range.setEnd(editor, 0);
                selection.addRange(range);
            }
        }
        document.addEventListener("click", make_selection_valid);
        document.addEventListener("keypress", make_selection_valid);

        function get_selected_range()
        {
            var selection = window.getSelection();
            if(selection.rangeCount < 1)
            {
                var range = document.createRange();
                range.setStart(editor, 0);
                range.setEnd(editor, 0);
                return range;
            }
            else
            {
                return selection.getRangeAt(0);
            }
        }

        function get_range_as_text_offset(tgt_node, range)
        {
            var search_node = range.startContainer;

            var offset = range.startOffset;

            /* Sum up all text nodes until the first non-text (annotated) one. */
            var prev_node = null;
            while(search_node && search_node.nodeType == 3)
            {
                /* Not for the first node. We use startOffset for text nodes. */
                if(prev_node)
                    offset += search_node.textContent.length;
                prev_node = search_node;
                search_node = search_node.previousSibling;
            }

            if(search_node)
            {
                /* If we found a non-text node (annotated!)  on the same level we can use its data-end annotation to calculate our offset. */
                offset += parseInt(search_node.getAttribute("data-end"));
            }
            else
            {
                /* Otherwise we can use the parent's (annotated!) data-start annotation. */
                search_node = prev_node.parentNode;
                offset += parseInt(search_node.getAttribute("data-start"));
            }

            /* Now we need to find the offset from tgt_node to our parent hm_node. */

            /* First we find our parent hm_node. */
            while(
                search_node &&
                (
                    !search_node.getAttribute('id') ||
                    !search_node.getAttribute('id').startsWith('hm_node_')
                )
            )
            {
                search_node = search_node.parentElement;
            }

            /* No containing hm_node_*. We must be the first text element in editor. */
            if(!search_node)
                return offset;

            /* And sum up all lengths until our target node. */
            while(search_node && !search_node.isSameNode(tgt_node))
            {
                search_node = search_node.previousSibling;
                if(search_node)
                {
                    offset += parseInt(search_node.getAttribute("data-end"));
                }
            }

            return offset;
        }

        function new_range_by_text_offset(node, offset)
        {
            while(node != null)
            {
                var new_offset = offset - node.textContent.length;

                if(new_offset <= 0)
                {
                    if(node.firstChild == null)
                    {
                        var range = new Range();
                        range.setStart(node, offset);
                        range.setEnd(node, offset);
                        return range;
                    }
                    else
                    {
                        node = node.firstChild;
                    }
                }
                else
                {
                    offset = new_offset;
                    node = node.nextSibling;
                }
            }

            return null;
        }

        function maybe_scroll_to_range(range)
        {
            var hidden = document.createElement("span");
            hidden.textContent = ".";
            range.insertNode(hidden);
            hidden.scrollIntoViewIfNeeded(false);
            hidden.parentNode.removeChild(hidden);
        }

        var parse_timeout = null;
        var parse_ranges = [];
        function start_incremental_parsing_throttled(range)
        {
            parse_ranges.push(range.cloneRange());
            if(!parse_timeout)
            {
                parse_timeout = setTimeout(
                    function()
                    {
                        parse_timeout = null;
                        start_incremental_parsing_from_ranges();
                        parse_ranges = [];
                    },
                    100
                );
            }
        }

        function start_incremental_parsing_from_ranges()
        {
            var start_node = Infinity;
            var end_node = -Infinity;

            for(range in parse_ranges)
            {
                ids = get_range_start_end(range);
                range.detach();

                if(ids[0] == -1)
                    start_node = -1;
                else
                    start_node = Math.min(start_node, ids[0]);

                if(ids[1] == -1)
                    end_node = -1;
                else
                    end_node = Math.max(end_node, ids[1]);
            }

            start_inremental_parsing(start_node, end_node);
        }

        function get_range_start_end(range)
        {
            var start_node = -1;
            var end_node = -1;

            /* Find the start and end of the area we need to reparse. */
            for(var i = 0; i < 2; ++i)
            {
                var id = -1;

                if(i == 0)
                    var node = range.startContainer;
                else
                    var node = range.endContainer;

                var is_first = true;
                var is_last = true;

                if(node.nodeType == 3)
                {
                    if(range.startOffset-1 != 0)
                        is_first = false;
                    if(range.endOffset-1 == node.textContent.length-1)
                        is_last = false;

                    node = node.parentElement;
                };

                var prev_node = node;
                /* Find the parent hm_node_ _OR_ go all the way back up to the
                 * editor node. */
                while(
                    !node.getAttribute('id') ||
                    (
                        !node.getAttribute('id').toLowerCase() == "editor" &&
                        !node.getAttribute('id').startsWith('hm_node_')
                    )
                )
                {
                    if(node.previousSibling)
                        is_first = false;
                    if(node.nextSibling)
                        is_last = false;

                    prev_node = node;
                    node = node.parentElement;
                }


                if(node.getAttribute('id').toLowerCase() == "editor")
                {
                    /* Start with our parent one below the editor node. */
                    node = prev_node;

                    while(
                        node.nodeType != 1 ||
                        !node.getAttribute('id') ||
                        !node.getAttribute('id').startsWith('hm_node_')
                    )
                    {
                        if(i == 0)
                            node = node.previousSibling;
                        else
                            node = node.nextSibling;

                        /* If we didn't find any we need to start to reparse
                         * from the edges. */
                        if(!node)
                            break;
                    }

                    /* If we know we need to reparse from the edges we already
                       found our bounds. */
                    if(!node)
                    {
                        if(i == 0)
                            start_node = -1;
                        else
                            end_node = -1;

                        break;
                    }
                }

                if(is_first && i == 0)
                    node = node.previousSibling;
                if(is_last && i != 0)
                    node = node.nextSibling;

                if(node && node.nodeType == 1)
                {
                    var id_str = node.getAttribute('id');
                    if(id_str)
                    {
                        var match = id_str.match(/^hm_node_(\d+)$/);
                        if(match)
                            id = parseInt(match[1]);
                    }
                }

                if(i == 0)
                    start_node = id;
                else
                    end_node = id;
            }

            return [start_node, end_node];
        }

        function start_inremental_parsing(start_node, end_node)
        {
            var range = get_selected_range();
            if(start_node >= 0)
                node = document.getElementById("hm_node_" + start_node);
            else
                node = editor.firstChild;
            var offset = get_range_as_text_offset(node, range);

            var id = java.start_parsing(start_node, end_node);

            node = document.getElementById("hm_node_" + id);

            var range = new_range_by_text_offset(node, offset);

            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            update_line_numbers();
        }

        function update_line_numbers()
        {
            var editor = document.getElementById("editor");
            var line_numbers = document.getElementById("numbers");

            while(line_numbers.hasChildNodes())
                line_numbers.removeChild(line_numbers.firstChild);

            var editor_rect = editor.getBoundingClientRect();
            line_numbers.style.height = "" + editor.offsetHeight + "px";

            var elements = document.getElementsByClassName("new_line");
            var height = window.innerHeight || document.documentElement.clientHeight;

            /* Don't recalculate them if they are more than 2 windows out of the screen. */

            /* Search for the element with the smallest rect.top that is bigger than -height. */
            var min = 0;
            var max = elements.length;
            var index;
            do
            {
                index = ((max + min)/2) >> 0; /* Integer maths! */

                if(min+1 >= max)
                    break;

                var element = elements.item(index);
                var rect = element.getBoundingClientRect();

                if(rect.top < -height)
                {
                    min = index;
                }
                else if(rect.top > -height)
                {
                    max = index;
                }
                else
                {
                    break;
                }
            }
            while(min != max);

            /* Now iterate through the elements until the first one has a bottom that is further down than 2*height */;
            for(var i = index; i < elements.length; i++)
            {
                var element = elements.item(i);

                var rect = element.getBoundingClientRect();
                if(rect.bottom - height > height)
                    break;

                var top = rect.top - editor_rect.top;

                number = document.createElement("div");
                number.setAttribute("class", "line_number");
                number.textContent = "" + i;
                number.style.position = "absolute";
                number.style.top = "" + top + "px";
                number.style.height = "0px";
                number.style.width = "2.5em";
                number.style.textAlign = "right";
                number.style.overflow = "visible";
                number.style.color = "gray";

                line_numbers.appendChild(number);
            }
        }

        document.addEventListener("keydown",
            function(e)
            {
                make_selection_valid(e);

                if(e.keyCode == 8)
                {
                    e.stopPropagation();
                    e.preventDefault();

                    var selection = window.getSelection();
                    if(selection.isCollapsed)
                        selection.modify("extend", "backward", "character");

                    selection.deleteFromDocument();

                    make_selection_valid(e);
                    maybe_scroll_to_range(get_selected_range());
                    start_incremental_parsing_throttled(get_selected_range());
                }
                else if(e.keyCode == 46)
                {
                    e.stopPropagation();
                    e.preventDefault();

                    var selection = window.getSelection();
                    if(selection.isCollapsed)
                        selection.modify("extend", "forward", "character");

                    selection.deleteFromDocument();

                    make_selection_valid(e);
                    maybe_scroll_to_range(get_selected_range());
                    start_incremental_parsing_throttled(get_selected_range());
                }
            }
        );

        document.addEventListener("keypress",
            function(e)
            {
                make_selection_valid(e);

                e.stopPropagation();
                e.preventDefault();

                var range = get_selected_range().cloneRange();
                range.deleteContents();

                var new_text = String.fromCharCode(e.charCode);
                if(e.charCode == 13)
                {
                    new_text = "\n";
                }

                var text = document.createTextNode(new_text);
                range.insertNode(text);
                range.selectNode(text);
                range.collapse(false);

                var selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                make_selection_valid(e);
                maybe_scroll_to_range(range);
                start_incremental_parsing_throttled(range);
            }
        );

        document.addEventListener("paste",
            function(e)
            {
                make_selection_valid(e);

                e.stopPropagation();
                e.preventDefault();

                var hm_node_id_left = 0;
                var hm_node_id_right = 0;

                var clipboard_data = e.clipboardData;
                var text = clipboard_data.getData('text/plain');

                var range = get_selected_range().cloneRange();
                range.deleteContents();
                var text_node = document.createTextNode(text);
                range.insertNode(text_node);
                range.selectNode(text_node);
                range.collapse(false);

                var selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                maybe_scroll_to_range(range);
                start_incremental_parsing_throttled(range);
            }
        );

        /* If we don't throttle this resizing gets _really_ slow. */
        var resize_timeout = null;
        window.addEventListener("resize", resize_throttled);
        function resize_throttled()
        {
            if(!resize_timeout)
                resize_timeout = setTimeout(
                    function()
                    {
                        resize_timeout = null;
                        resize_handler();
                    },
                    100
                );
        }

        function resize_handler()
        {
            update_line_numbers();
        }

        /* If we don't throttle this resizing gets _really_ slow. */
        var scroll_timeout = null;
        window.addEventListener("scroll", scroll_throttled);
        function scroll_throttled()
        {
            if(!scroll_timeout)
                scroll_timeout = setTimeout(
                    function()
                    {
                        scroll_timeout = null;
                        scroll_handler();
                    },
                    100
                );
        }

        function scroll_handler()
        {
            update_line_numbers();
        }
    </script>
</head>
<body>
    <div id="numbers"></div>
    <div id="editor" contenteditable="true"></div>
</body>
</html>
